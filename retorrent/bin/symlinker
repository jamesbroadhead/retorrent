#!/usr/bin/python

import os
import sys

from os_utils import os_utils 
from retorrentlib import confparse

debug = 0 
def debugprint(string, debuglevel=1):
	"""
	debuglevel = 0 - always print
	debuglevel = 1 - print if -d
	debuglevel = 2 - print if -dd
	"""
	if debuglevel <= debug :
		print string

def main():
	foo,folderopts = confparse.parse_retorrentconf()	

	for_postprocessing = {}
	for folderopt in folderopts:
				
		category_home = folderopt['home']	
		os_utils.mkdir_p(os.path.expanduser(category_home))
		debugprint('Considering: %s' % (os.path.basename(category_home)))
	
		removed = []
		# remove broken symlinks 
		for elem in os.listdir(category_home):
			elem_path = os.path.join(category_home,elem)	
			
			if not os.path.islink(elem_path):
				
				if os.path.isfile(elem_path):
					print '!! file in symlink dir: %s' % (elem_path)
				elif not len(os.listdir(elem_path)):
						os.rmdir(elem_path)
				else:
					for f in os.listdir(elem_path):
						fpath = os.path.join(elem_path,f)
						if not os.path.islink(fpath):
							print 'Non-symlinked file detected in folder', elem_path
							print '\t Non-symlinked folders should only contain symlinks'
						elif not os.path.isfile(fpath):
							# broken symlink
							os.remove(fpath)

			else:
				if os.path.lexists(elem_path) and not os.path.exists(elem_path):
					print 'Broken symlink! Removing.', elem
					removed += [elem]	
					os.remove(elem_path)
		
		if category_home in folderopt['paths']:
			print 'The content home is in the list of content paths. Cannot continue.'
			continue
		
		# /mnt/foo/video/tv for instance
		for content_dir in folderopt['paths']:
			debugprint('Looking at: %r' % (content_dir,))	
			if not os.path.exists(content_dir):
				os.makedirs(content_dir)
			
			for content in os.listdir(content_dir):
				content_path = os.path.join(content_dir, content)	
				debugprint('Examining: %s' % (content_path,), 2)
				# empty dir in content dir 
				#print content_path	
				if os.path.isdir(content_path) and not len(os.listdir(content_path)):
						os.rmdir(content_path)
						print '%s: removed empty content dir' % (content_path,)
						continue
				
				# symlinks in content dir
				elif os.path.islink(content_path):
					print '%s: symlink in content dir'
					if not os.path.exists(content_path):
						print '%s: symlink was broken, removing'
						os.remove(content_path)

				# content can either be movie.avi or series.name/
				content_abspath = os.path.abspath(os.path.join(content_dir,content))
				symlink_path = os.path.abspath(os.path.join(category_home,content))
				# link directly if symlink doesn't exist
				if not os.path.exists(symlink_path):
					os.symlink(content_abspath,symlink_path)
					if content in removed:
						print 'Replaced a broken symlink',content

				# symlink with same name already exists
				# 	and doesn't point to same location
				elif os.path.islink(symlink_path) and \
					not os.path.realpath(symlink_path) == \
						os.path.realpath(content_abspath):
					
					debugprint('%s already exists, and there are two candidates, %s and %s' % (os.path.islink(symlink_path), os.path.realpath(symlink_path), os.path.realpath(content_abspath)))
					oldlink_realpath = os.path.realpath(symlink_path)
					
					# they're both links to different directories
					#	create dir, populate with symlinks to the content 
					#	in both
					if os.path.isdir(oldlink_realpath) and \
							os.path.isdir(content_abspath):
						# remove oldlink
						os.remove(symlink_path)	
						# mkdir foo
						os_utils.mkdir_p(symlink_path)
						
						link_contents(oldlink_realpath,symlink_path)
						link_contents(content_abspath,symlink_path)
					else:
						print 'Duplicate files, can\'t combine :('
						print '\t',oldlink_realpath
						print '\t',content_abspath
				
				# dir found in category_home. 
				#	Broken symlinks and empty dirs should be gone already
				elif not os.path.islink(symlink_path) and \
						os.path.isdir(symlink_path):
					debugprint('Will post-process: %s' % (symlink_path,))	
					for_postprocessing.setdefault(symlink_path, []).append(content_abspath)	
				else:
					# the symlink exists + points at this content :D
					debugprint('%s - OK' % (symlink_path,), 2)	
					pass
	
	for symlink_path, content_paths in for_postprocessing.iteritems():
		debugprint('Postprocessing: %s' % (symlink_path,))
		for c in content_paths:	
			link_contents(c, symlink_path)

	# prune dirs full of symlinks to the same place
	for elem in os.listdir(category_home):
		
		if os.path.isdir(elem):
			# If dir is full of symlinks, and all symlinks are to the same dir, remove all symlinks, then symlink the dir
			symlinkdir_contents_paths = [ os.path.join(symlink_path, l) for l in os.listdir(symlink_path) ] 

			if all([os.path.islink(f) for f in symlinkdir_contents_paths]) and \
					all_symlinks_to_same_dir(content_abspath, symlinkdir_contents_paths):
				for f in symlinkdir_contents_paths:
					if os.path.islink(f):	
						os.remove(f)
					else:
						print 'ERROR! Tried to remove a file! %s' % (f)
				os.rmdir(symlink_path)	
				print '\t%s no longer sourced from multiple locations' % (content,)
				os.symlink(content_abspath,symlink_path)
			else:
				link_contents(content_abspath, symlink_path)
				print '\t%s: sourced from multiple locations' % (content,)

	
def link_contents(content_path, linkdir_path):
	content_realpath = os.path.realpath(content_path)	
	for fn in os.listdir(content_realpath):
		f_realpath = os.path.join(content_realpath,fn)
		f_sympath = os.path.join(linkdir_path,fn)

		if not os.path.exists(f_sympath):
			os.symlink(f_realpath,f_sympath)
		elif os.path.exists(f_sympath) and \
				not os_utils.sym_sametarget(f_sympath,f_realpath):
			print 'Duplicate content found for ',f_sympath,' in'
			print '==>', os.path.realpath(f_sympath)
			print '   ', os.path.realpath(f_realpath)
		else:
			# symlink exists, but points to same location.
			pass

def all_symlinks_to_same_dir(d, symlinks):
	print d	
	for s in symlinks:
		if not os.path.abspath(os.path.dirname(os.path.realpath(s))) == os.path.abspath(d):
			return False
	return True

if __name__ == '__main__':
	if '-d' in sys.argv:
		debug = 1
	elif '-dd' in sys.argv:
		debug = 2
	main()
